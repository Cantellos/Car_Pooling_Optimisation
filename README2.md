## Local Search Algorithms

These algorithms aim to improve an initial solution (typically generated by a constructive method such as Greedy or K-Means) by exploring its neighborhood to find better alternatives based on the objective function — minimizing the total kilometers driven.

### Local Search 1 Algorithm (Simple Local Search)

**Idea:**

This basic local search iteratively explores the neighborhood of the current solution using simple moves. If a better solution is found in the neighborhood, it replaces the current one. The process continues until no further improvements are possible.

**Implementation:**

- **Move 1**: Swap a passenger not included in any route with one that is part of a route.
- **Move 2**: Change the order of passengers within the same route to reduce the total route cost.
- **Move 3**: Insert an unassigned passenger into a route that has available capacity.

These moves are applied in sequence, and if any of them improves the objective function, the change is accepted.

### Local Search 1 Results

![ResultLocalSearch1](link_to_be_added)

---

### Local Search 2 Algorithm (Variable Neighborhood Descent - VND)

**Idea:**

This method sequentially applies each neighborhood move to local optimality. It explores different neighborhoods one after another and always adopts the best improving move before moving to the next neighborhood structure.

**Implementation:**

- Executes **Move 1** until no improvement is found.
- Then continues with **Move 2**, again until no improvement is possible.
- Finally applies **Move 3** in the same way.
- Among the final solutions obtained from each phase, the one with the best cost is chosen.

### Local Search 2 Results

![ResultLocalSearch2](link_to_be_added)

---

### Local Search 3 Algorithm (Very Large Neighborhood Search - VLSN)

**Idea:**

This variant considers all neighborhood moves and applies the one that gives the largest improvement in each iteration. The process is repeated until no move can further improve the solution.

**Implementation:**

- At each step, evaluate all three moves across all users and drivers.
- Select the single move that yields the **maximum decrease in total distance**.
- Repeat until all moves fail to produce improvements.

This is the most computationally demanding of the three but also the most effective in many cases.

### Local Search 3 Results

![ResultLocalSearch3](link_to_be_added)

---

## Multi Start Local Search Algorithm

This metaheuristic enhances the search by performing multiple independent runs of the VLSN algorithm, each starting from a different initial solution. These initial solutions are generated using randomized versions of the constructive algorithms (Greedy Random, Greedy, K-Means).

**Idea:**

By exploring several starting points, the algorithm increases diversity and reduces the risk of getting trapped in local minima.

**Implementation:**

- Generate 10 randomized starting solutions using Greedy Random, Greedy 1, or K-Means 2.
- For each, apply the Very Large Neighborhood Search (VLSN).
- Keep the solution with the best objective function value across all runs.

### Multi Start Local Search Results

![ResultMultiStartLocalSearch](link_to_be_added)

---

## Genetic Algorithm

The Genetic Algorithm (GA) is a population-based metaheuristic inspired by the principles of natural selection. It evolves a population of solutions over multiple generations to find high-quality carpooling configurations.

**Implementation:**

- **Initial Population**: 100 individuals generated from randomized variants of the solutions obtained with Greedy Random, Greedy 1, or K-Means 2.
- **Representation**: Each individual is a matrix where each row corresponds to a driver’s route.
- **Selection**: Roulette wheel method based on fitness (lower total distance implies higher fitness).
- **Crossover**: 
  - Select a random number of "genes" (routes) from parent 1.
  - Complete the offspring with routes from parent 2, ensuring no duplicate nodes.
  - Only driver routes are inherited; direct passengers are excluded.
- **Mutation**:
  - With 20% probability, swap a passenger from a route with an unassigned passenger, if it leads to improvement.
  - Remaining drivers complete their routes greedily; unassigned passengers travel alone.

The algorithm runs for 100 generations, keeping the individual with the lowest cost.

**Performance Considerations**:

- GA is computationally intensive.
- More effective on larger and more diverse instances.
- Achieves improvements over initial solutions, especially when the solution space is diverse.

### Genetic Algorithm Results

![ResultGeneticAlgorithm](link_to_be_added)
